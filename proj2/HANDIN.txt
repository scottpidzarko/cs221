Student Name #1: Vincent Tan
Student ugrad login #1: g0l0b

Student Name #2: Scott Pidzarko
Student ugrad login #2: w2p8

Team name (for fun!): The Final Countdown (the last assignment of the term is this one)

Acknowledgment that you understand and have followed the course's
collaboration policy
(http://www.ugrad.cs.ubc.ca/~cs221/current/syllabus.shtml#conduct):

TODO: [[Vincent Tan]]

TODO: submit using: make handin-proj2

----------------------------------------------------------------------

Approximate hours on project: TODO: 30

----------------------------------------------------------------------

For teams, rough breakdown of work: TODO: Vincent 50%, Scott 50%

----------------------------------------------------------------------

Acknowledgment of assistance: TODO: TAs for clarifying confusing choice of words, stackoverflow, past labs for certain functions

----------------------------------------------------------------------

Questions:

For the explanations, generally a sentence or two should be enough.
Type your answers directly in this file.


1.  Give tight big-theta bounds on the worst-case runtime of the
add and find functions in LinkedListDict.

For add, we have theta(1), simply because we add to the front. For find, we have theta(n), where n is size of list, since we sequentially walk through the list.

2.  Run the 5x5 slider puzzle with HeapPriorityQueue and LinkedListDict.
What runtime do you get?  This is roughly the performance you had
for Project 1.

29.108 seconds

3.  Run the 5x5 slider puzzle with HeapPriorityQueue and your working
AVLDict, LinearHashDict, and DoubleHashDict classes.
What are your run times?  How do they compare to Q2?

AVLDict-2.546, LinearHashDict-0.813, DoubleHashDict-0.998 (all in seconds)

For the remaining questions, we'll keep using HeapPriorityQueue,
but switch to the UNSOLVABLE 3x3 slider puzzle to have something
a bit more challenging for your program.  When we ask you for
the average depth or number of probes, treat the "More" row as
being equal to 29.

4.  What is your runtime using AVLDict?  Based on the statistics
printed out, what is the average depth of the find calls?

5.221s. Average depth is 9.28 probes. We acknowledge our implementation for AVLDict has some issues - it funcitons as a dictionary but we can't determine why it isn't balancing right

5.  What is your runtime using LinearHashDict?  Based on the statistics
printed out, what is the average number of probes for the find calls?

2.3s, 2.8 probes

6.  Change your LinearHashDict to use the notprimes array instead of the
primes array for the table size.  (See the example in the constructor,
and be sure to make the change every where in your program that you set
the tablesize.)  Now, what is your runtime using LinearHashDict?
And what is the average number of probes for the find calls?
(Be sure to change the code back to using primes before you handin
your code!)

2.9s, 12.5 probes

7.  What is your runtime using DoubleHashDict?  Based on the statistics
printed out, what is the average number of probes for the find calls?

2.6s, 2.0 probes

8.  Change your DoubleHashDict to use the notprimes array instead of the
primes array for the table size.  What happens?  Why?

Unbearable runtimes; It ran for over 10 minutes until manually stopped. This happens because the notprimes sizes conflicts horribly with the hash functions, causing a lot of hash collisions

9.  Keeping your DoubleHashDict using notprimes, change to using hash3
instead of hash2 for the probing.  What is your runtime using DoubleHashDict?
What is the average number of probes for the find calls?
(Be sure to change the code back to using primes before you handin
your code!)

2.7s, 4.7 probes.

10(Bonus).  For a very small bonus (but a lot of fun), try to explain
precisely why the chosen hash function (hash1 in the DoubleHashDict)
interacts so poorly with the notprimes table sizes.

The multiplier in hash1 is 31, which is very close to 3*10, factors of the sizes in notprimes (which are 10^n and 3*10^n). Therefore, there is a high chance of hash collisions

----------------------------------------------------------------------

We will be checking your implementations of AVLDict, LinearHashDict,
and DoubleHashDict.
